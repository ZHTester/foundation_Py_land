计算机通信是通过网卡进行的 。。。。。
socket 基本概念
socket本质上就是在2台网络互通的电脑之间，架设一个通道，两台电脑通过这个通道来实现数据的互相传递。
我们知道网络 通信 都 是基于 ip+port 方能定位到目标的具体机器上的具体服务，操作系统有0-65535个端口，
每个端口都可以独立对外提供服务，如果 把一个公司比做一台电脑 ，那公司的总机号码就相当于ip地址，
每个员工的分机号就相当于端口， 你想找公司某个人，必须 先打电话到总机，然后再转分机 。
建立一个socket必须至少有2端， 一个服务端，一个客户端， 服务端被动等待并接收请求，客户端主动发起请求， 连接建立之后，双方可以互发数据。


http smtp
dns ftp
ssh snmp icmp ping dhcp


osi 七层
 应用
 表示
 会话
 传输  协议都是跑在传输层上面的
 网络  ip地址
 数据链路 mac  不认识Ip地址
 物理层

tcp/ip  三次握手 四次断开

UDP

封装 send receive 都是基于socket
自己写一些协议那么就必须自己会一些协议

socket 就是发数据和收数据

一个计算机最多可以开放65535个端口

静态方法  与类无关 不能访问类里面任何的属性和方法
类方法 只能访问类变量
属性 @property
  把一个方法变成静态属性

反射
  getattr (obj str)
  setattr (obj str val)
  hasatter 判断是否存在
  delattr

  new方法咸鱼init方法执行
  __call__



异常
finally 无论如何都执行
raise
except Exception as e 放在异常处理最后面
else  没发生异常就执行


断言:
a = '123'
assert type(a) is str

print('dddd')

socket
 所有的网络协议本质上都是对数据的收发
 tcp/ip  send recv
 udp

 服务端建立socket需要建立哪几部

 server = socket.socket(Af.Inet,socket.SOCK_STREAM)
 server.bind(localhost,9999)
 server.listen
while true
 conn,addr = server.accept  # 阻塞
 多次通讯
 while True
   print(' new conn', addr)
   if not data:
   break
   data = conn.recv(1024) #最大接受的值是8192 接收数据 recv默认是阻塞的

   print(data)
   conn.send(data.upper())

# 客户端已断开 conn.recv 接收到的数据都是空数据了


客户端 client
client = socket.socket()
client.connent(serverip, 9999)
client.send(data)
client.send(data)
client.recv(dat)


socketserver

简化了去编写网络服务器
socketserver 是对socket的封装

 BaseServer |
+------------+
      |
      v
+-----------+        +------------------+
| TCPServer |------->| UnixStreamServer |
+-----------+        +------------------+
      |
      v
+-----------+        +--------------------+
| UDPServer |------->| UnixDatagramServer
 1 创建sockctserver  你必须创建一个请求处理类，并且这个类要继承baserequestHandler 并且还要重写父亲类里面的handle(）方法
 2 你必须实例化TCPServer，并且传递server IP 和你上面创建的请求处理类给这个TCPServer
   server.handle._request() 只处理一个请求
   server.server_forever 处理多个请求，永远执行
 3 你必须实例化TCPServer并且床底server ip和你上面创建的请求处理类，给这个TCPServer
















