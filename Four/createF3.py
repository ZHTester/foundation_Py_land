"""

递归生成器
如果要处理任意的嵌套该怎么办，例如: 可能要使用来表示树形结构(也可以用于特定的饿树类，但是原理是一样的)
每层嵌套需要增加一个for循环，但因为不知道有几层嵌套，所以必须把解决方案变得灵活，现在就是求组与递归(recursion)的时候了

当flatten被调用的时候，有两种可能性(处理递归时大部分都是有两种情况)，基本情况和需要递归的情况，在基本的情况中，函数被
告知展开一个元素(比如一个数字)，这种情况下，for循环就会抛出一个异常(因为视图对一个数字进行迭代)，生成器就会产生一个元素
  如果展开的是一个列表(或者其他的可迭代对象)，那么就要进行特殊处理，程序必须遍历所有的字列表(一些可能不是列表)，并对他们调用
  flatten，然后使用另一个for循环来产生被展开列表中的所有元素，这看起来不可思议，但却能工作


注意: 这么做就会有一个问题，如果nested是一个类似于字符串的对象(字符串，unicode，userString等等)，那么他就是一个序列，不会引发序列，不会
引发typeerror，但是你不想对这样的对象进行迭代

不应该对flatten 函数中对类似于字符串的对象进行迭代，处于两个主要的原因，首先要实现的是将类似于字符串的对象当成原子值，
而不是当成被展开的序列，其实对他们进行迭代实际上会导致无穷递归，因为一个字符串的第一个元素是另一个长度为1的字符串
而长度为1的字符串的第一个元素就是字符串本身。

为了处理这种情况，则必须在生成器的开始处添加一个检查语句，试着将传入的对象和一个字符串拼接，看看会不会出现typeerror，
这是检查一个对象是不是雷诗雨字符串的最简单的最快速的方法


如果表达式nested+ 引发了一个typeError 他就会被忽略，然而如果没有引发typeError那么内层的tyr语句中else会引发一个他自己的
TypeError异常，这就会按照原来的样子生成类似于字符串的对象(在Except 子句的外面)

"""


def flatten(nested):
    try:
        try:
            nested + " "
        except TypeError:
            pass
        else:
            raise TypeError

        for sublist in nested:
            for element in flatten(sublist):
                yield element
    except TypeError:
        yield nested


# a = list(filter([1], [2], 3, 4, [5[6, 7]], 8))
# print(a)

b = list(filter(['foo', ['bar', ['bazz']]]))
print(b)
