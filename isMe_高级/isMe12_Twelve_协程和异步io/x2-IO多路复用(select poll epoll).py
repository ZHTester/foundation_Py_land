# coding=utf-8
__author__ = 'landing'
__data__ = '2019/1/26  15:29'

"""
<----------------------->
IO多路复用(select poll epoll)
*** 所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，
    也就是concurrent 10 000 connection(这也是c10k这个名字的由来).
1 一个服务器上如何去处理多个用户了，从而达到支持千万级别的客户端问题了。
2 Unix5种IO模型  1 阻塞式IO - 这个也就是我们在使用unix最常见的IO模型 最初级的编程IO模型
                2  非阻塞式IO - 
                3  I/O复用
                4  信号驱动式IO
                5 异步IO(POSIX的aio_系列函数)
  这类型的IO模式都是递进式的发展模式。
<----------------------->
3 阻塞式IO  <----> 在阻塞式的IO情况下，会浪费大量的IO(cpu资源)，因为这种阻塞式的IO，这样的情况下CPU是空闲的。

    这种模型最为常见，用户空间调用API(read, write )会转化成一个I/O请求，一直等到I/O请求完成API调用才会完成。
    这意味着： 在API调用期间用户程序是同步的的；这个API调用会导致系统以阻塞的模式执行I/O，如果此时没有数据则
    一直“等待”（放弃CPU主动挂起——Sleep状态） （注意，对于硬盘来说是不会出现阻塞的，无论是什么时候读它总是有数
    据。常见的阻塞设备是终端、网卡之类的）。
    
    以 read 为例子，它由三个参数组成，第一个函数是文件描述符；第二个是 应用缓冲 ；第三个参数是需要读取的字节数。
    经过系统调用会以阻塞模式执行I/O，I/O模块读取数据后会放入到PageCache中；最后一步是把数据从PageCache复制到 
    应用缓冲 。如果I/O请求无法得到满足——没有数据，则主动让出CPU直到 有数据 （注意，即便系统调用让出CPU也未必
    真的就让出。read函数是同步的，所以CPU还是会被用户空间代码占用）。
<-------------------------> 
4 非阻塞式IO <----> 也就是无论数据是否有返回都会立马返回(中间是没有等待期)数据不占用CPU浪费IO资源 这个时候的阻塞是不会消耗CPU的
  *不好之处*: 比如说socket五次连接，立马返回的话，也就是没有连接成功，这个时候连接就会抛出异常的,这个时候我们就是需要一个while循环
   不断的去询问是否建立好了这样的连接。
   
   数据是先进入到内核，然后内核保护内存的机制，首先在内核内存中存放1G内存，然后在分配给应用，然后在将数据传入到用户空间中，用户空间中
   的数据然后在发送给用户使用。 

    这种模式通过调用 read 、 write 的时候指定 O_NONBLOCK 参数。和“同步阻塞”模式的区别在于系统调用的时候它是以非阻塞的
    方式执行，无论是否有数据都会立即返回。 以 read 为例，如果成功读取到数据它返回读取到的字节数；如果此时没有数据则返回-1，
    同时设置errno为EAGAIN（或者EWOULDBLOCK，二者相同）。所以这种模式下我们一般会用一个“循环”不停的尝试读取数据，处理数据。  
<------------------------->    
5 I/O多路复用 <-----> 也就是会先去询问那些socket准备好，然后调用出来飞阻塞的进行
    通过一种机制，一个进程可以监视多个文件描述符（套接字描述符）一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知
    程序进行相应的读写操作（这样就不需要每个用户进程不断的询问内核数据准备好了没）常用的IO多路复用方式有select、poll和epoll
    1 在调用select的时候，系统会给我们返回那些socket或者说哪些信号量是准备好了的,select其实也是阻塞的方法(阻塞试的)，也就是不断的查看 
      询问那些socket准备好了可以提供我们下一次调用了。
    2 


  
"""












