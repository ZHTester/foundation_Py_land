# coding=utf-8
__author__ = 'landing'
__data__ = '2019/1/26  15:29'

"""
----> C10与IO多路复用引发的一些列问题 <-----

<----------------------->
IO多路复用(select poll epoll)
*** 所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，
    也就是concurrent 10 000 connection(这也是c10k这个名字的由来).
1 一个服务器上如何去处理多个用户了，从而达到支持千万级别的客户端问题了。
2 Unix5种IO模型  1  阻塞式IO - 这个也就是我们在使用unix最常见的IO模型 最初级的编程IO模型
                2  非阻塞式IO - 
                3  I/O复用
                4  信号驱动式IO(这个IO使用的场景是不多的  ----> 故省略)
                5  异步IO(POSIX的aio_系列函数)
  这类型的IO模式都是递进式的发展模式。
<----------------------->
3 阻塞式IO  <----> 在阻塞式的IO情况下，会浪费大量的IO(cpu资源)，因为这种阻塞式的IO，这样的情况下CPU是空闲的。

    这种模型最为常见，用户空间调用API(read, write )会转化成一个I/O请求，一直等到I/O请求完成API调用才会完成。
    这意味着： 在API调用期间用户程序是同步的的；这个API调用会导致系统以阻塞的模式执行I/O，如果此时没有数据则
    一直“等待”（放弃CPU主动挂起——Sleep状态） （注意，对于硬盘来说是不会出现阻塞的，无论是什么时候读它总是有数
    据。常见的阻塞设备是终端、网卡之类的）。
    
    以 read 为例子，它由三个参数组成，第一个函数是文件描述符；第二个是 应用缓冲 ；第三个参数是需要读取的字节数。
    经过系统调用会以阻塞模式执行I/O，I/O模块读取数据后会放入到PageCache中；最后一步是把数据从PageCache复制到 
    应用缓冲 。如果I/O请求无法得到满足——没有数据，则主动让出CPU直到 有数据 （注意，即便系统调用让出CPU也未必
    真的就让出。read函数是同步的，所以CPU还是会被用户空间代码占用）。
<-------------------------> 
4 非阻塞式IO <----> 也就是无论数据是否有返回都会立马返回(中间是没有等待期)数据不占用CPU浪费IO资源 这个时候的阻塞是不会消耗CPU的
  *不好之处*: 比如说socket五次连接，立马返回的话，也就是没有连接成功，这个时候连接就会抛出异常的,这个时候我们就是需要一个while循环
   不断的去询问是否建立好了这样的连接。
   
   数据是先进入到内核，然后内核保护内存的机制，首先在内核内存中存放1G内存，然后在分配给应用，然后在将数据传入到用户空间中，用户空间中
   的数据然后在发送给用户使用。 

    这种模式通过调用 read 、 write 的时候指定 O_NONBLOCK 参数。和“同步阻塞”模式的区别在于系统调用的时候它是以非阻塞的
    方式执行，无论是否有数据都会立即返回。 以 read 为例，如果成功读取到数据它返回读取到的字节数；如果此时没有数据则返回-1，
    同时设置errno为EAGAIN（或者EWOULDBLOCK，二者相同）。所以这种模式下我们一般会用一个“循环”不停的尝试读取数据，处理数据。  
<------------------------->    
5 I/O多路复用 <-----> 也就是会先去询问那些socket准备好，然后调用出来非阻塞的进行
    通过一种机制，一个进程可以监视多个文件描述符（套接字描述符）一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知
    程序进行相应的读写操作（这样就不需要每个用户进程不断的询问内核数据准备好了没）常用的IO多路复用方式有select、poll和epoll
    1 在调用select的时候，系统会给我们返回那些socket或者说哪些信号量是准备好了的,select其实也是阻塞的方法(阻塞式的方法，如果没有准备好的文件句柄，
      则会一直阻塞)，也就是不断的查看询问那些socket准备好了可以提供我们下一次调用了。这样的话，我们就可以随时进入下一次的调用了，这样就不会进行长久
      的等待操作，IO多路复用是现在多并发使用的较高的一个点，也是高性能编程的多路并发关键点之一的地方。
    2 recvfrom 在接受到一个准备好的socket以后，然后这里就是存在了一个时间上的调用，(这里也就是将内核数据复制到用户空间中),
<------------------------->    
5 信号式驱动IO <-----> 也就是会先去询问那些socket准备好，然后调用出来非阻塞的进行

<------------------------->    
6 异步IO  <-----> 这里的异步IO也才是真正意义上的异步IO,实际上就是以
                  aio_read ---- 系统调用 ----- 无数据准备好
                                返回            
                                                          
                  |                                         |
                  |                                         |         ----> 等待数据
进程继续执行       |                                         |
                                                        数据报准备好
                                                        复制数据报
                  |                                         |
                  |                                         |         ----> 将数据复制到内核空间
                  |   信号处理      <------>                 
                      程序处理      递交在aio_read中       复制完成
                      数据报        指定信号
<---------------------> select poll epoll 
select poll epoll都是IO多路复用的机制，IO多路复用就是通过一种机制，一个进程可以监控多个描述符，一旦某个描述符就绪
(一般是读就绪或者写就绪)能够通知程序进行相应操作，但是select poll epoll本质上都是同步IO，因为他们都需要在读写事件
就绪后自己负责进行读写，也就是说这个读写的郭川是阻塞的，而异步IO无需自己负责进行读写，异步IO的实现会负责把数据从内
核拷贝到用户控件中去  

<---------------------> select 原理
select 是通过系统调用来监视着一个由多个文件描述符（file descriptor）组成的数组，当select()返回后，数组中就绪的文件
描述符会被内核修改标记位(其实就是一个整数)，使得进程可以获得这些文件描述符从而进行后续的读写操作。select饰通过遍历来
监视整个数组的，而且每次遍历都是线性的。

----------------------------------------------------------------------------------------------------------
优点: 
select目前几乎在所有的平台上支持，良好跨平台性。
缺点: 
1 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多的时候会很大
2 单个进程能够监视的fd数量存在最大限制，在linux上默认为1024（可以通过修改宏定义或者重新编译内核的方式提升这个限制）
3 并且由于select的fd是放在数组中，并且每次都要线性遍历整个数组，当fd很多的时候，开销也很大

select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能
够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式
提升这一限制，但是这样会造成效率的降低

<---------------------> poll - 原理
poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，
但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制
于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。

<---------------------> epoll - 原理
    epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，
    没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个
    事件表中，这样在用户空间和内核空间的copy只需一次。

-------------
-------------
select poll epoll 的选择方式
1 当并发高(连接活跃度)的情况下，epoll 实际上是要比 select的好  
2 并发性不高同时连接很活跃 这样的情况下select要比epoll好

"""














