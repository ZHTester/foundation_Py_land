# coding=utf-8
__author__ = 'landing'
__data__ = '2019/2/11  9:40'
"""
协程是什么
C10M问题
1: 如何利用8核心CPU，64G内存，在10gbps的网络上保持1000万的并发. <----> 这里就需要引出什么是协程
2: 我们编码最初采用得是同步得模式,后面采用的模式是同步+事件回调的模式+循环模式
3: 协程就是要解决回调函数编写难的一个问题
4: 目前遇到的问题， 1 回调模式编码复杂程度高
                   2 同步编程的并发性不高 
                   3 多线程编程需要线程间同步(Lock 也就是会降低线程间的并发性)
                   ***解决的办法:***
                   -1- (采用同步的方式去编写异步的代码)   ----> 这样代码如何去实现   ---> 采用同步的方式去写代码
                   -2- (使用单线程去切换任务)   1 线程是由操作系统来切换的,单线程切换程序员需要自己去调度任务(也就是这个时候操作系统不在帮我们去调度了)
                                              2 不在需要锁，并发性高(也就是不需要在大量的切换了消耗大量的内存空间)
                                              3 如果单线程内切换函数 他的性能远高于线程切换，而且他的并发性更高
                   ----> 所以为了解决这样的一个问题，就出现了协程这个(进程 -> 线程 -> 协程)
                       
5: 传统函数调用过程  A->B->C  这里阻塞
6: 协程 - > 有多个入口的函数 可以暂停的函数(可以向暂停的地方(函数)传入值)  生成器恰好就是一个可以暂停的函数
"""
# 我们需要一个暂停的函数，并且在适当的时候可以恢复该函数继续执行


def get_url(url):
    # do something 1  获取到请求的url
    html = get_html(url)   # 函数暂停 这个时候就会切换到另外一个函数去执行-消耗IO的操作可以暂停--- 这里就是可以进行一个切换的操作将html传出去然后在传回来继续执行
    # parse html cpu进行解析页面获取到源代码
    urls = parse_url(html)  # 继续执行的意思就是上一个函数能被下一个函数所使用


def get_url(url):
    # do something 1  获取到请求的url
    html = get_html(url)   # 函数暂停 这个时候就会切换到另外一个函数去执行 消耗IO的操作
    # parse html cpu进行解析页面获取到源代码
    # urls = parse_url(html)

